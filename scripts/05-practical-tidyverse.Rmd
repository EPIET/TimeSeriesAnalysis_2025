# Practical Session 5 {-}

## Periodicity {-#title-5}

```{r, knitr-global-chunk-05t, include=FALSE, cache=FALSE}
source("_common.R")
```

## Expected learning outcomes {-#learn-5}

By the end of this session, participants should be able to:

- assess the existence of periodicity in surveillance data

- fit and interpret models containing a trend and one or several sine and cosine 
curves on surveillance data to model both trend and periodicity


## Task 5.1 {-#task-5-1}

Using `mortality_agg.dta`, visually assess the existence of any periodicity
in the total number of deaths (cyclical patterns). What do you think the period
is, if any? Discuss your results with your peers. 


## Task 5.2 {-#task-5-2}

Using `mortality_agg.dta`, check statistically for the existence of periodicity.
Then, fit a model on the data for the relevant period(s). How many different
periods are you including in your model? Test statistically if the inclusion of
more than one period contributes to the fit of the model. Discuss your results.
When is mortality highest? When is it lowest? What do you think might be the
reason and how would you test for that statistically?


## Task 5.3 {-#task-5-3}

Assess visually how the average reported mortality in any specific average week
of the year compares with the rest. In other words, how does the average week X
of all years compare to the overall weekly average in terms of recorded
mortality? 


## Task 5.4 (Optional) {-#task-5-4}

Assess the existence of periodicity in the `dis1` dataset.


## Help for Task 5.1 {-#solution-5-1}

Required source code.

```{r, task-5-1-source-Rscript}
source("src/tidyverse/session_5.R")
```


R has a number of functions which produce a *periodogram* - we will use the
`periodogram` function from the `TSA` package. 

```{r, task-5-1-periodogram}
mortper <- periodogram(mortz$cases)

str(mortper)
```


The `periodogram` function plots the estimated periodogram for a given
time series and also returns various useful outputs as a list which we can use
for other analyses.

This type of plot is interpreted by identifying peaks. Convert the frequencies
at which peaks occur to periods by taking the reciprocal.

```{r, task-5-1-periodogram-freq}
mortper_recip <-
    tibble(
        freq = mortper$freq[order(-mortper$spec)],
        spec = mortper$spec[order(-mortper$spec)]
    ) %>%
    mutate(reciprocal_freq = 1 / freq)

mortper_recip
```


The above lines of code extract two variables (`freq` and `spec`) from the `mortper`
object and place them in a `tibble` data.frame. Simultaneously, both columns values
are order by descending order of the spectral variable.

It allows to find the frequencies with the highest peaks in the periodogram and
converts those frequencies to periods (which are numbers of weeks for this data).
 
The `order` function is used here to order the frequencies of the periodogram
in reverse order (i.e. largest first) of the values of the periodogram (the
negative sign).

The reciprocal values are calculated and stored on the `reciprocal_freq` variable

To plot the periodogram more like the STATA `epergram` function does, use the
following expression:

```{r, task-5-1-periodogram-epergram-tidy}
mortper_df <-
    tibble(
        freq = mortper$freq,
        spec = mortper$spec
    )

ggplot(data = mortper_df) +
    geom_line(mapping = aes(x = 1 / freq, y = log(spec))) +
    scale_x_continuous(limits = c(0, 160)) +
    labs(x = "Period", y = "Log(density)") +
    tsa_theme()
```


In this case, to use ggplot2 we must first extract the required data (`freq` and
`spec` variables) and place them in a dataset. This is done with `mortper_df`.

Is there any periodicity? If so, what is the period?


## Help for Task 5.2 {-#solution-5-2}

As the periodogram shows periodicity close to 52 weeks, we will use a
*sine curve* of a 52-week period. Note that periodicity with a *period of* 
*one year is also referred to as seasonality*.

Fit a linear regression of `cases` with a sine predictor term:

```{r, task-5-2-sin52}
mortz <-
    mortz %>%
    mutate(sin52 = sin(2 * pi * Date / 52))


sinemodel <- lm(cases ~ sin52, data = mortz)
summary(sinemodel)
```


Plot the fitted values against the original data and comment.

```{r, task-5-2-sin52-plot-tidy}
ggplot(data = mortz) +
    geom_point(mapping = aes(x = Date, y = cases), alpha = 0.4) +
    geom_line(
        mapping = aes(x = Date, y = unname(fitted(sinemodel))),
        colour = "green"
    ) +
    scale_y_continuous(limits = c(0, NA)) +
    labs(x = "Index", y = "Mortality", title = "Regression model: one sine term") +
    tsa_theme()
```


*Addition of the cosine* - In order to have an appropriate phase in your model
(you don't have to worry about identifying it; this will happen automatically),
you need to use *both* a sine and a cosine curve with the same period.
The sum of these two curves gives the periodicity for the specified period
and the phase best describing our data.

You can fit a linear model for the cases, using sine and cosine as explanatory variables. 
Plot the fitted values against the data and comment: 

```{r, task-5-2-sin52-cos52}
mortz <-
    mortz %>%
    mutate(cos52 = cos(2 * pi * Date / 52))

sinecosmodel <- lm(cases ~ sin52 + cos52, data = mortz)
summary(sinecosmodel)
```


```{r, task-5-2-sin52-cos52-plot-tidy}
ggplot(data = mortz) +
    geom_point(mapping = aes(x = Date, y = cases), alpha = 0.4) +
    geom_line(
        mapping = aes(x = Date, y = unname(fitted(sinecosmodel))),
        colour = "green"
    ) +
    scale_y_continuous(limits = c(0, NA)) +
    labs(x = "Index", y = "Mortality", title = "Regression model: sine, cosine terms") +
    tsa_theme()
```


How does the fit look graphically?

Now adjust not only for periodicity, but also for trend:

```{r, task-5-2-sin52-cos52-trend}
sinecostrendmodel <- lm(cases ~ sin52 + cos52 + Date, data = mortz)
summary(sinecostrendmodel)
```


```{r, task-5-2-sin52-cos52-trend-plot-tidy}
ggplot(data = mortz) +
    geom_point(mapping = aes(x = Date, y = cases), alpha = 0.4) +
    geom_line(
        mapping = aes(x = Date, y = unname(fitted(sinecostrendmodel))),
        colour = "green"
    ) +
    scale_y_continuous(limits = c(0, NA)) +
    labs(
        x = "Index",
        y = "Mortality",
        title = "Regression model: trend, sine, cosine terms"
    ) +
    tsa_theme()
```


*A model with a trend plus 2 sine and 2 cosine curves* - To fit the model
better, we could try to add more sine/cosine curves, of a period corresponding
to the second strongest peak in the model (26 weeks). This will allow for
cycles (periods) of not only 52, but also 26 weeks, should we think there
might be half-yearly cycles which are relevant. In this case, for instance,
there may be elevated mortality in winter, but also in summer during heatwaves.

Generate sine and cosine terms with a period of 26 weeks and name
them `sin26` and `cos26`. Add these two new terms to the previous model.

Plot the results, compare with the previous model and comment on it.

```{r, task-5-2-sin26-cos26-trend}
mortz <-
    mortz %>%
    mutate(
        sin26 = sin(2 * pi * Date / 26),
        cos26 = cos(2 * pi * Date / 26)
    )

sine2cos2trendmodel <- lm(cases ~ sin52 + cos52 + sin26 + cos26 + Date,
    data = mortz
)
summary(sine2cos2trendmodel)
```



```{r, task-5-2-sin26-cos26-trend-plot-tidy}
ggplot(data = mortz) +
    geom_point(mapping = aes(x = Date, y = cases), alpha = 0.4) +
    geom_line(
        mapping = aes(x = Date, y = unname(fitted(sine2cos2trendmodel))),
        colour = "green"
    ) +
    scale_y_continuous(limits = c(0, NA)) +
    labs(
        x = "Index",
        y = "Mortality",
        title = "Regression model with trend plus 2 sine and cosine terms"
    ) +
    tsa_theme()
```


Is the addition of variables `sin26` and `cos26` a statistically significant
contribution to your model?

```{r, task-5-2-sin26-cos26-trend-drop}
drop1(sine2cos2trendmodel, test = "F") %>% broom::tidy()
```

The `drop1` function here shows whether any variables can be dropped from the
linear regression model. A significant $p$ value suggests that a variable is
important and should not be dropped.


## Help for Task 5.3 {-#solution-5-3}

We already discussed how to check for periodicity by using sine and
cosine curves. You can also check for seasonality graphically by
grouping all week numbers together first (weeks 1 of all years together,
weeks 2 of all years together etc.) and then plotting the average number
of deaths by week number; this would give you a graph with all average
weekly numbers of deaths:

```{r, task-5-3-week-aggr}
means_cases <-
    mortagg %>%
    group_by(week) %>%
    summarise(mean_cases_wk = mean(cases)) %>%
    ungroup()

reference_mean_cases <- mean(mortagg$cases)
```


Create a bar graph of the mean number of cases and the overall mean
number of cases (y-axis) by time (x-axis):

```{r, task-5-3-week-aggr-mean-plot-tidy}
ggplot(data = means_cases) +
    geom_col(mapping = aes(x = week, y = mean_cases_wk), colour = "darkblue", fill = "blue") +
    geom_hline(yintercept = reference_mean_cases, colour = "green") +
    scale_y_continuous(limits = c(0, NA)) +
    labs(
        x = "Week",
        y = "Average cases",
        title = "Average cases by week number"
    ) +
    tsa_theme()
```


What do these results suggest?

Plot the data with the fitted trend from the model:

```{r, task-5-3-week-aggr-fitted-trend-plot-tidy}
ggplot(data = mortz) +
    geom_point(mapping = aes(x = Date, y = cases), alpha = 0.4) +
    geom_line(
        mapping = aes(x = Date, y = unname(fitted(linregmodel))),
        colour = "green"
    ) +
    scale_y_continuous(limits = c(0, NA)) +
    labs(
        x = "Index",
        y = "Mortality",
        title = "Mortality with fitted trend"
    ) +
    tsa_theme()
```


Residuals are the difference between your predicted and observed values.
As you *may* remember from the linear regression lecture in the
MVA module, small residuals are a sign of good model fit, as they
mean that there is little difference between your model's
predicted values and your observed data. Also, residuals in linear
models are supposed to be normally distributed and not have a trend.

Plot the residuals. 

```{r, task-5-3-time-residuals-plot-tidy}
## histogram of residuals
lin_mod_resid <-
    enframe(residuals(linregmodel), name = "time_i", value = "resid") %>%
    mutate(time_i = as.numeric(time_i))

ggplot(data = lin_mod_resid, mapping = aes(x = resid)) +
    geom_histogram(colour = "white", bins = 30) +
    geom_rug() +
    labs(y = "Number", x = "Residuals") +
    tsa_theme()


## residuals by time variable
ggplot(data = lin_mod_resid) +
    geom_point(mapping = aes(x = time_i, y = resid), alpha = 0.4, colour = "darkorange") +
    scale_y_continuous(limits = c(NA, NA)) +
    labs(
        x = "Index",
        y = "Residuals",
        title = "Residuals by time"
    ) +
    tsa_theme()
```


As mentioned above, in order to use ggplot2, it is preferable to prepare a dataset
that contains the variables to be plotted. In this case, we wish to plot the
residuals from the last computed model. the residual are stored inside the 
`linregmodel` object (you can manually look for them using `str(linregmodel)`).

The `residuals` function allows us to collect the residuals from a model object.
However they return a named vector (e.g. a collection of observations, in this case
residuals numbers). The `enframe` function shown above converts this vector into
a tibble. 

We can also obtain fitted values from a model object using the `fitted` function,
as previously exemplified.

Create a bar graph of the mean residuals by week:

```{r, task-5-3-week-residuals-plot-tidy}
mean_resid_by_week <-
    lin_mod_resid %>%
    bind_cols(week = mortagg$week) %>%
    group_by(week) %>%
    summarise(mean_resid_wk = mean(resid)) %>%
    ungroup()

ggplot(data = mean_resid_by_week) +
    geom_col(
        mapping = aes(x = week, y = mean_resid_wk),
        colour = "darkblue", fill = "blue"
    ) +
    scale_y_continuous(limits = c(NA, NA)) +
    labs(
        x = "Week number",
        y = "Mean of residuals",
        title = "Mean of residuals by week number"
    ) +
    tsa_theme()
```


Regress the residuals on time and examine the predicted values of the model
(seasonality):

```{r, task-5-3-residuals-model-plot-tidy}
residtimemodel <-
    lm(residuals(linregmodel) ~ 0 + factor(mortz$week))

lin_mod_season <-
    enframe(fitted(residtimemodel), name = "time_i", value = "fitted") %>%
    mutate(time_i = as.numeric(time_i))

ggplot(data = lin_mod_season) +
    geom_point(
        mapping = aes(x = time_i, y = fitted),
        alpha = 0.4, colour = "purple"
    ) +
    scale_y_continuous(limits = c(NA, NA)) +
    labs(
        x = "Index",
        y = "Residuals",
        title = "Note seasonality remains after estimated trend removed"
    ) +
    tsa_theme()
```


We know that the mean of the errors of the previous model is zero, so we ask
R to assume the intercept of the current model is zero using the `0 +` part
of the model formula above. 

We have used `factor` to tell R to regard week as a categorical variable rather
than a numeric variable. 
