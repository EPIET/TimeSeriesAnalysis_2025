{
  "hash": "c9260e5d5a577d5e61900ffc199853ab",
  "result": {
    "engine": "knitr",
    "markdown": "# Practical Session 7: Forecasting {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list=ls())\n\n# Install pacman if not installed already, and activate it\nif (!require(\"pacman\")) install.packages(\"pacman\")\n\n# Install, update and activate libraries\npacman::p_load(\n  here, \n  rio, \n  skimr,\n  tsibble,\n  TSA,\n  tidyverse,\n  ciTools\n)\n\n# Create tsa_theme from previous exercise to be used in ggplot.\ntsa_theme <- theme_bw() + \n        theme(\n            plot.title = element_text(face = \"bold\", \n                                      size = 12),\n            legend.background = element_rect(fill = \"white\", \n                                             size = 4, \n                                             colour = \"white\"),\n            # legend.justification = c(0, 1),\n            legend.position = \"bottom\",\n            panel.grid.minor = element_blank()\n        )\n                                             \n\n\n# Prepare ts data (same as in practical 6)\n#load(here(\"data\", \"mortagg2_case_6.Rdata\"))\nmortagg <- import(here(\"data\", \"mortagg2.csv\"))\n\nmortz <-\n    mortagg %>%\n    mutate(year_week = make_yearweek(year = year, week = week),\n           index = seq.int(from = 1, to = nrow(mortagg)),\n           sin52 = sin(2 * pi * week / 52), \n           cos52 = cos(2 * pi * week / 52),\n           sin26 = sin(2 * pi * week / 26), \n           cos26 = cos(2 * pi * week / 26)) %>%\n    as_tsibble(index = index)\n\n# Model with trend and seasonality\nmort_sine2cos2trendmodel <- glm(cases ~ index + sin52 + cos52 + sin26 + cos26,\n                           family = \"poisson\",\n                           data = mortz)\n```\n:::\n\n\n## Expected learning outcomes {#learn-7 .unnumbered}\n\nBy the end of this session, participants should be able to: \n- understand the use of forecasting in public health surveillance data\n- forecast the expected number of cases of a disease into the future\n\n## Task 7.1 {#task-7-1 .unnumbered}\n\nJanuary 2020: Your boss received a phone call from the Ministry of Health. She is part of a committee that is responsible for setting the alert levels for mortality in Spain for the next year (2020). Before doing so, she gives you the task to forecast the total expected number of deaths for 2020 based on the historical data up to and including 2019.\n\n## Task 7.2 (Optional) {#task-7-2 .unnumbered}\n\nJanuary 2020: A committee member is interested to get a better understanding of when there were periods of unusually high excess mortality and asks you to provide an analysis that highlights the time when these occurred.\n\n## Task 7.3 (Optional) {#task-7-3 .unnumbered}\n\nJanuary 2021: your boss needs to inform the Ministry of Health about excess deaths so far during the first year of the pandemic.\n\n## Help for Task 7.1 {#solution-7-1 .unnumbered}\n\nFirst plot the data and the fitted Poisson model up to end of 2020.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mortz) +\n    geom_line(\n        mapping = aes(x = year_week, y = cases),\n        colour = \"black\",\n        alpha = 1.2\n    ) +\n    geom_line(\n        mapping = aes(x = year_week, y = mort_sine2cos2trendmodel$fitted),\n        colour = \"red\",\n        alpha = 1.2\n    ) +\n    scale_x_yearweek(date_labels = \"%Y-%W\", date_breaks = \"24 weeks\") +\n    labs(x = \"Year Week\", y = \"Weekly cases\") +\n    tsa_theme + \n    theme(axis.text.x = element_text(angle = 30, hjust = 1)) \n```\n\n::: {.cell-output-display}\n![](07-practical_files/figure-html/task-7-1-explore-1.png){width=100%}\n:::\n:::\n\n\nThe dataset has records up to 2019-W52, and you would like to project the data (forecast) into 2020.\n\n**Step 1:** create a new time series object for 2020. Note that 2020 has 53 weeks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npred.df <-\n    tibble(\n        year=2020,\n        week  = 1:53,\n        index = 521:(521+53-1), # add 53 weeks\n        year_week = make_yearweek(year = year, week = week),\n        sin52 = sin(2 * pi * week / 52),\n        cos52 = cos(2 * pi * week / 52),\n        sin26 = sin(2 * pi * week / 26),\n        cos26 = cos(2 * pi * week / 26),\n        pop = 47318050) %>%                # Spanish pop in 2020 (1st Jan)\n    as_tsibble(index = index)\n\nview(pred.df)\n```\n:::\n\n\n**Step 2:** Calculate the expected values and 95% prediction intervals for each week of 2020 assuming that the Poisson regression model with trend and 2 seasonality terms based on the previous years is appropriate.\n\nFor this, we apply `mort_sine2cos2trendmodel` to the new data and we predict cases with the `add_ci` function of the `ciTools` package using bootstrapping. Bootstrapping is a statistical method where you draw random samples from your data, and analyze each of this samples. [More info](https://en.wikipedia.org/wiki/Bootstrapping_(statistics))\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(12589)\npred.mort <- ciTools::add_ci(pred.df,\n                            mort_sine2cos2trendmodel,\n                            names=c(\"lPI\", \"uPI\"),\n                            yhatName=\"pred_cases\",\n                            response=TRUE,\n                            type=\"boot\",\n                            nSims=1000)\nhead(pred.mort, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  year week index year_week     sin52     cos52     sin26     cos26      pop\n1 2020    1   521  2020 W01 0.1205367 0.9927089 0.2393157 0.9709418 47318050\n2 2020    2   522  2020 W02 0.2393157 0.9709418 0.4647232 0.8854560 47318050\n3 2020    3   523  2020 W03 0.3546049 0.9350162 0.6631227 0.7485107 47318050\n4 2020    4   524  2020 W04 0.4647232 0.8854560 0.8229839 0.5680647 47318050\n5 2020    5   525  2020 W05 0.5680647 0.8229839 0.9350162 0.3546049 47318050\n  pred_cases      lPI       uPI\n1   9668.633 9505.031  9847.676\n2   9816.630 9649.887 10004.593\n3   9917.123 9743.460 10116.956\n4   9965.433 9788.115 10167.868\n5   9959.873 9784.202 10162.163\n```\n\n\n:::\n:::\n\n**Step 3:** plot the expected number of deaths per week for 2020 with prediction intervals\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = pred.mort) +\n    geom_line(\n        mapping = aes(x = year_week, y = pred_cases),\n        colour = \"red\",\n        alpha = 0.7\n    ) +\n    geom_ribbon(\n        mapping = aes(x = year_week, ymin = lPI, ymax = uPI),\n        fill = \"red\",\n        alpha = 0.1\n    ) +\n    scale_y_continuous(limits = c(0, NA)) +\n    scale_x_yearweek(date_labels = \"%Y-%W\", date_breaks = \"4 weeks\") +\n    labs(x = \"Year Week\", y = \"Predicted weekly fatalities\") +\n    tsa_theme + \n    theme(axis.text.x = element_text(angle = 30, hjust = 1)) \n```\n\n::: {.cell-output-display}\n![](07-practical_files/figure-html/task-7-1-prediction-interval-plot-tidy-1.png){width=100%}\n:::\n:::\n\n\n**Step 4:** Calculate the total number of expected deaths in 2020 in Spain.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Total predicted cases in 2020, with lPI and uPI\npred.mort %>% \n  summarise(\n    pred_cases_2020 = sum(pred_cases),\n    pred_cases_2020_lPI = sum(lPI),\n    pred_cases_2020_uPI = sum(uPI)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  pred_cases_2020 pred_cases_2020_lPI pred_cases_2020_uPI\n1        441385.8            435448.6            447514.4\n```\n\n\n:::\n:::\n\n\n## Help for Task 7.2 {#solution-7-2 .unnumbered}\n\nCUSUM (cumulative sum) is a graphical method that can be used to determine when there is a change in a process (all-cause mortality in this example). In TSA it can also be used to decide whether there is a need to revise the model e.g. include a covariate or whether there have been changes in the seasonality.\n\nUsing expected values from the previous regression model, you can calculate the cumulative sum of the differences between the weekly observed and expected numbers of deaths:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmortz <- mortz %>%\n  mutate(fit_cases = mort_sine2cos2trendmodel$fit,  # get predicted cases\n         \n         # calculate differences\n         difference = cases - fit_cases,\n         cumsum_excess = cumsum(difference),\n         diff_zero = cases - mean(fit_cases),\n         cumsum_zero = cumsum(diff_zero))\n```\n:::\n\n\nPlot this cumulative sum of the residuals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mortz) +\ngeom_line(\n        mapping = aes(x = year_week, y = diff_zero),\n        colour = \"green\",\n        alpha = 0.7,\n        lwd = 1\n    ) +\n    geom_line(\n        mapping = aes(x = year_week, y = cumsum_zero),\n        colour = \"orange\",\n        alpha = 0.7,\n        lwd = 1\n    ) +\n    scale_x_yearweek(date_labels = \"%Y-%W\", date_breaks = \"1 year\") +\n    labs(x = \"Year\", y = \"Cumulative excess cases\") +\n    tsa_theme\n```\n\n::: {.cell-output-display}\n![](07-practical_files/figure-html/task-7-2-diff-exp-obs-plot-tidy-1.png){width=100%}\n:::\n:::\n\n\n## Help for Task 7.3 {#solution-7-3 .unnumbered}\n\nPlot the actual number of deaths and compare with the predictions from the model based on 2010-2019.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load mortality data for 2020\nmort2020 <- import(here(\"data\", \"mortagg2020.csv\"))\n\n# order mort2020 from week 1 to week 53, same as in pred.mort\nmort2020 <- mort2020 %>% arrange(week)\n\n# add actual deaths from 2020 in pred.mort\npred.mort <- pred.mort %>% \n  mutate(cases = mort2020$cases)\n\nggplot(data = pred.mort) +\n    geom_line(\n        mapping = aes(x = year_week, y = pred_cases),\n        colour = \"red\",\n        alpha = 0.7,\n        lwd = 0.5\n    ) +\n    geom_ribbon(\n        mapping = aes(x = year_week, ymin = lPI, ymax = uPI),\n        fill = \"red\",\n        alpha = 0.4\n    ) +\n    geom_line(\n        mapping = aes(x = year_week, y = cases),\n        colour = \"black\",\n        alpha = 0.7,\n        lwd = 1.2\n    ) +\n    scale_x_yearweek(date_labels = \"%Y-%W\", date_breaks = \"4 weeks\") +\n    labs(x = \"Year Week\", y = \"Predicted weekly cases\") +\n    tsa_theme + \n    theme(axis.text.x = element_text(angle = 30, hjust = 1)) \n```\n\n::: {.cell-output-display}\n![](07-practical_files/figure-html/task-7-3-diff-obs-predict-plot-tidy-1.png){width=100%}\n:::\n:::\n\n\nExcess deaths can be calculated as the difference of the actual number of fatalities per week and the predicted mean, or the predicted upper 95% PI.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npred.mort <- pred.mort %>%\n  mutate(\n    difference_mean = cases - pred_cases,\n    cusum_excess_mean = cumsum(difference_mean),\n    difference_uPI = cases - uPI,\n    cusum_excess_uPI = cumsum(difference_uPI)\n  )\n\n\nggplot(data = pred.mort) +\n    geom_line(\n        mapping = aes(x = year_week, y = cusum_excess_mean),\n        colour = \"orange\",\n        alpha = 0.7,\n        lwd = 1\n    ) +\n    geom_line(\n        mapping = aes(x = year_week, y = cusum_excess_uPI),\n        colour = \"blue\",\n        alpha = 0.7,\n        lwd = 1\n    ) +   \n    #scale_y_continuous(limits = c(-100, NA)) +\n    scale_x_yearweek(date_labels = \"%Y-%W\", date_breaks = \"4 weeks\") +\n    labs(x = \"Year\", y = \"Cumulative excess cases\") +\n    tsa_theme\n```\n\n::: {.cell-output-display}\n![](07-practical_files/figure-html/unnamed-chunk-1-1.png){width=100%}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# save(list = ls(pattern = 'mort'), file = here(\"data\", \"mortagg2_case_7.RData\"))\n#load(here(\"data\",\"mortagg2_case_7.RData\"))\n```\n:::\n\n",
    "supporting": [
      "07-practical_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}